#!/usr/bin/env python

########################################################################
#                                                                      #
#               This software is part of the ECharts package           #
#                  Copyright (c) 2006 AT&T Corp.                       #
#                      and is licensed under the                       #
#                  Common Public License, Version 1.0                  #
#                            by AT&T Corp.                             #
#                                                                      #
########################################################################

import sys, getopt, string, os, os.path, re, time

# Filter out select ECharts constructors/methods/fields from the HTML
# for ECharts machine classes produced by javadoc. Also add a button
# to each such page to display a page graphically depicting the
# machine.

# I know that the very idea of this program is abominable, however Sun
# forced me to do it. What I needed to do was selectively remove
# mention of some internal ECharts constructors/fields/methods from
# the HTML generated by javadoc. Unfortunately, Sun's javadoc 'api'
# does not support customizing the output produced by their HTML
# doclet. I actually managed to override enough of the javadoc
# internal classes to get something working under Java 1.4, but in
# Java 1.5 all the internal classes were refactored in a way that made
# overriding impossible. The only solutions for Java 1.5 are to come
# up with a clean-room re-implementation of Sun's HTML doclet, or
# implement a program that edits the HTML output by javadoc.  And that
# is what has motivated this program. By some fortunate twist of fate,
# the HTML output by javadoc versions 1.4 and 1.5 is practically
# identical for my purpose so this progam works for the output
# produced by both versions. However, I fully expect to be confronted
# with this problem all over again when I am faced with Java
# 1.6. Unless of course Sun open sources their code....

_version = "1.0-beta"

# globals - read-only

# used to identify that file corresponds to ECharts machine class
# documentation - see postProcessFile() - the optional space is
# present in HTML generated by javadoc 1.5 but not in HTML from
# javadoc 1.4
machineClassPattern = re.compile('"extended by( )?">.*org.echarts.Machine($|<)')

# used to identify method detail entries to be filtered out - see
# filterMethodDetail()
methodDetailPattern = re.compile("^(state_|transition_|clearSubmachineReference|set_transition_)")

# used to identify field summary entries to be filtered out - see
# filterFieldSummary()
fieldSummaryPattern = re.compile("_NUM_STATES|_states|_messagelessTransitions|_messageTransitions")

# used to identify field detail entries to be filtered out - see
# filterDetailSummary()
fieldDetailPattern = re.compile("_NUM_STATES|_states|_messagelessTransitions|_messageTransitions")

def getVersion():
	return 'javadocpp version %s' % _version

# Post-process the files in the specified directory.
def postProcess(ignored, dir, files):
	# ignore doc-files directories
	if string.split(dir, os.sep)[-1] == "doc-files": return

	for file in files:
		# process html files located in dir
		filePath = dir + os.sep + file
		# looking at html files whose names don't start with 'package'
		if os.path.isfile(filePath) and \
				(file[-5:] == ".html" or file[-4:] == ".htm") and \
				not file[:7] == "package" and \
				not file[:4] == "help" and \
				not file[:8] == "constant" and \
				not file[:10] == "allclasses" and \
				not file[:8] == "overview" and \
				not file[:5] == "index" and \
				not file[:10] == "serialized" and \
				not file[:10] == "deprecated" and \
				not file == "Machine.html" and \
				not file == "AndMachine.html" and \
				not file == "OrMachine.html" and \
				not file == "TransitionMachine.html" and \
				not file == "StateMachine.html" and \
				not file == "BasicMachine.html" and \
				not file == "DynamicMachine.html":
			postProcessFile(filePath)

def postProcessFile(filePath):
	inFile = open(filePath)
	inLines = inFile.readlines()
	inFile.close()
	numLines = len(inLines)
	processed = False
	index = 0
	while index < numLines and not processed:
		# process only machine class files
		if machineClassPattern.search(inLines[index]):
			sys.stdout.write("javadocpp: processing %s\n" % filePath)
			postProcessMachineFile(filePath, inLines, index, numLines)
			processed = True
		elif "<!-- Post-processed by ECharts javadocpp" in inLines[index]:
			sys.stdout.write("javadocpp: already processed %s\n" % filePath)
			processed = True
		index = index + 1
	
# strip extra constructors, fields and methods from summary and detail
# sections
def postProcessMachineFile(filePath, inLines, index, numLines):
	# rename original file with ".orig" extension
	os.rename(filePath, filePath + ".orig")
	# use original file name for processed output
	outFile = file(filePath, "w")
	# copy everything read from file so far to output file and add an
	# identifying header
	outFile.writelines(inLines[:5])
	outFile.writelines("<!-- Post-processed by ECharts javadocpp (version %s) on %s -->\n" % \
					   (_version, time.strftime("%a %b %d %H:%M:%S %Z %Y")))
	for i in range(5, index + 1):
		outFile.write(inLines[i])
	machineName = string.split(string.split(filePath, os.sep)[-1], ".")[0]
	# add machine button
	index = addMachineButton(inLines, index + 1, numLines, machineName, outFile)
	# look for comments delimiting summary or detail section to
	# determine what to strip next
	while index < numLines:
		outFile.write(inLines[index])
		if "FIELD SUMMARY" in inLines[index]:
			index = filterFieldSummary(inLines, index + 1, numLines, machineName, outFile)
		elif "CONSTRUCTOR SUMMARY" in inLines[index]:
			index = filterConstructorSummary(inLines, index + 1, numLines, outFile)
		elif "METHOD SUMMARY" in inLines[index]:
			index = filterMethodSummary(inLines, index + 1, numLines, outFile)
		elif "FIELD DETAIL" in inLines[index]:
			index = filterFieldDetail(inLines, index + 1, numLines, machineName, outFile)
		elif "CONSTRUCTOR DETAIL" in inLines[index]:
			index = filterConstructorDetail(inLines, index + 1, numLines, outFile)
		elif "METHOD DETAIL" in inLines[index]:
			index = filterMethodDetail(inLines, index + 1, numLines, outFile)
		else:
			index = index + 1
	outFile.close()

def addMachineButton(inLines, index, numLines, machineName, outFile):
	addedButton = False
	while index < numLines and not addedButton:
		if inLines[index] == "<HR>\n":
			# add button code
			outFile.write('<input class="button" value="Machine" type="submit" onclick="window.open(\'doc-files/%s.svg\')"><BR>\n' % machineName)
			addedButton = True
		outFile.write(inLines[index])
		index = index + 1
	# index pointing after "<HR>"
	return index

def filterFieldSummary(inLines, index, numLines, machineName, outFile):
	privateMachineFieldPattern = re.compile('>%s\..*</A>' % machineName)
	filteringComplete = False
	outFile.write(inLines[index])
	index = index + 1
	firstTable = True
	while index < numLines and not filteringComplete:
		if "fields_inherited_from_class_org.echarts.Machine" in inLines[index] and \
				not firstTable:
			# beginning of inherited field summary table
			while index < numLines and not filteringComplete:
				# skip all lines comprising the table
				if "</TABLE" in inLines[index]:
					# end of table
					filteringComplete = True
				else:
					index = index + 1
		elif "<TABLE" in inLines[index] and firstTable:
			# beginning of field summary table so start filtering
			# table entries
			outFile.write(inLines[index])
			entries = []
			entry = []
			index = index + 1
			while index < numLines and firstTable:
				# collect lines comprising an entry
				if "</TABLE" in inLines[index]:
					# end of table so no more entries
					for entry in entries:
						# write non-filtered entries
						outFile.writelines(entry)
					outFile.write(inLines[index])
					# decrement index since outer loop will increment
					# it again
					index = index - 1
					firstTable = False
				else:
					# append line to entry
					entry.append(inLines[index])
					if "</TR" in inLines[index]:
						# finished collecting lines comprising an entry
						if len(entry) > 3 and fieldSummaryPattern.search(entry[3]) or \
							len(entry) > 2 and privateMachineFieldPattern.search(entry[2]):
							# filter this entry
							pass
						else:
							# save this entry for writing when end of
							# table encountered
							entries.append(entry)
						entry = []
				index = index + 1
		else:
			outFile.write(inLines[index])
		index = index + 1
	# we're at line following "</TABLE..."
	return index

def filterConstructorSummary(inLines, index, numLines, outFile):
	filteringComplete = False
	while index < numLines and not filteringComplete:
		if "<!-- ==" in inLines[index]:
			# no constructor summary detail so return
			filteringComplete = True
		elif "<TABLE" in inLines[index]:
			outFile.write(inLines[index])
			# beginning of constructor summary table so start filtering
			# table entries
			entries = []
			entry = []
			index = index + 1
			while index < numLines and not filteringComplete:
				# collect lines comprising an entry
				if "</TABLE" in inLines[index]:
					# end of table so no more entries
					for entry in entries:
						# write non-filtered entries
						outFile.writelines(entry)
					outFile.write(inLines[index])
					filteringComplete = True
				else:
					# append line to entry
					entry.append(inLines[index])
					if "</TR" in inLines[index]:
						# finished collecting lines comprising an entry
						if len(entry) >= 5 and "machineCode)</CODE>" in entry[-5]:
							# filter this entry
							pass
						else:
							# save this entry for writing when end of
							# table encountered
							entries.append(entry)
						entry = []
				index = index + 1
		if not filteringComplete:
			outFile.write(inLines[index])
			index = index + 1
	# we're at line following "</TABLE..."
	return index

def filterMethodSummary(inLines, index, numLines, outFile):
	filteringComplete = False
	while index < numLines and not filteringComplete:
		outFile.write(inLines[index])
		if "<TABLE" in inLines[index]:
			# beginning of method summary table so start filtering
			# table entries
			entries = []
			entry = []
			index = index + 1
			while index < numLines and not filteringComplete:
				# collect lines comprising an entry
				if "</TABLE" in inLines[index]:
					# end of table so no more entries
					for entry in entries:
						# write non-filtered entries
						outFile.writelines(entry)
					outFile.write(inLines[index])
					filteringComplete = True
				else:
					# append line to entry
					entry.append(inLines[index])
					if "</TR" in inLines[index]:
						# finished collecting lines comprising an entry
						if len(entry) > 3 and \
								(">state_" in entry[3] or \
								 ">transition_" in entry[3] or \
								 ">clearSubmachineReference" in entry[3] or \
								 ">set_transition_" in entry[3]):
							# filter this entry
							pass
						else:
							# save this entry for writing when end of
							# table encountered
							entries.append(entry)
						entry = []
				index = index + 1
		index = index + 1
	# we're at line following "</TABLE..."
	return index - 1

def filterFieldDetail(inLines, index, numLines, machineName, outFile):
	privateFieldDetailPattern = re.compile('>%s\..*</A>' % machineName)
	filteringComplete = False
	while index < numLines and not filteringComplete:
		if "<!-- ==" in inLines[index]:
			# no field detail table so simply return
			filteringComplete = True
		elif "</TABLE" in inLines[index]:
			# beginning of field detail table so start filtering
			# table entries
			outFile.write(inLines[index])
			entries = []
			entry = []
			index = index + 1
			while index < numLines and not filteringComplete:
				# collect lines comprising an entry
				if "<!-- ==" in inLines[index]:
					# end of table so no more entries
					firstEntry = True
					for entry in entries:
						# write non-filtered entries
						if firstEntry and entry[0] == "<HR>\n":
							# skip horizontal rule if first line of
							# first entry
							outFile.writelines(entry[1:])
						else:
							outFile.writelines(entry)
						firstEntry = False
					filteringComplete = True
				else:
					# append line to entry
					entry.append(inLines[index])
					if "</DL>\n" == inLines[index] and "</DL>\n" in inLines[index-1]:
						# finished collecting lines comprising an
						# entry - pattern may be present on different
						# line depending on if it's the first entry or
						# not
						if (len(entry) > 1 and fieldDetailPattern.search(entry[1])) or \
								(len(entry) > 2 and fieldDetailPattern.search(entry[2])) or \
								 (len(entry) > 4 and privateFieldDetailPattern.search(entry[4])) or \
								  (len(entry) > 5 and privateFieldDetailPattern.search(entry[5])):
							# filter this entry
							pass
						else:
							# save this entry for writing when end of
							# table encountered
							entries.append(entry)
						entry = []
				index = index + 1
		if not filteringComplete:
			outFile.write(inLines[index])
			index = index + 1
	# return index for line "<!-- ... = CONSTRUCTOR DETAIL ="
	return index - 2

def filterConstructorDetail(inLines, index, numLines, outFile):
	filteringComplete = False
	while index < numLines and not filteringComplete:
		if "<!-- ==" in inLines[index]:
			# no field detail table so simply return
			filteringComplete = True
		elif "</TABLE" in inLines[index]:
			outFile.write(inLines[index])
			# beginning of constructor detail table so start filtering
			# table entries
			entries = []
			entry = []
			index = index + 1
			while index < numLines and not filteringComplete:
				# collect lines comprising an entry
				if "<!-- ==" in inLines[index]:
					# end of table so no more entries
					firstEntry = True
					for entry in entries:
						# write non-filtered entries
						if firstEntry and entry[0] == "<HR>\n":
							# skip horizontal rule if first line of
							# first entry
							outFile.writelines(entry[1:])
						else:
							outFile.writelines(entry)
						firstEntry = False
					filteringComplete = True
				else:
					# append line to entry
					entry.append(inLines[index])
					if "</DL>\n" == inLines[index]:
						# finished collecting lines comprising an
						# entry - first disjunct for javadoc 1.4 -
						# second disjunct for javadoc 1.5
						if (len(entry) >= 4 and "machineCode)" in entry[-4]) or \
								(len(entry) >=8 and "machineCode)" in entry[-8]):
							# filter this entry
							pass
						else:
							# save this entry for writing when end of
							# table encountered
							entries.append(entry)
						entry = []
				index = index + 1
		if not filteringComplete:
			outFile.write(inLines[index])
			index = index + 1
	# return index for line "<!-- ... = METHOD DETAIL ="
	return index - 2

def filterMethodDetail(inLines, index, numLines, outFile):
	filteringComplete = False
	while index < numLines and not filteringComplete:
		outFile.write(inLines[index])
		if "</TABLE" in inLines[index]:
			# beginning of method detail table so start filtering
			# table entries
			entries = []
			entry = []
			index = index + 1
			while index < numLines and not filteringComplete:
				# collect lines comprising an entry
				if "= END OF CLASS DATA =" in inLines[index]:
					# end of table so no more entries
					firstEntry = True
					for entry in entries:
						# write non-filtered entries
						if firstEntry and entry[0] == "<HR>\n":
							# skip horizontal rule if first line of
							# first entry
							outFile.writelines(entry[1:])
						else:
							outFile.writelines(entry)
						firstEntry = False
					filteringComplete = True
				else:
					# append line to entry
					entry.append(inLines[index])
					if "</DL>\n" == inLines[index] and "</DD>\n" == inLines[index-1]:
						# finished collecting lines comprising an
						# entry - first disjunct for javadoc 1.4 -
						# second disjunct for javadoc 1.5
						if (len(entry) > 2 and methodDetailPattern.match(entry[2])) or \
								(len(entry) > 3 and methodDetailPattern.match(entry[3])):
							# filter this entry
							pass
						else:
							# save this entry for writing when end of
							# table encountered
							entries.append(entry)
						entry = []
				index = index + 1
		index = index + 1
	# return index for line "<!-- ... = END OF CLASS DATA ="
	return index - 2

def optionsUsage(options):
	rv = ""
	for option in options.keys():
		rv = rv + string.ljust("--%s" % option, 25) + options[option] + "\n"
	return rv

def main():

	options = {}
	options["version"] = "Print program version and exit"
	options["help"] = "Print this message and exit"

	usage = """Usage: javadocpp [options] [javadocdirs]

Post process javadoc-generated HTML files located in the specified
javadoc directories to provide customized views of ECharts machine
class documentation. Note that the ech2javadoc translator should be
run on the Java source directories containing the ECharts machine
classes prior to running javadoc and javadocpp.

options:
%s
""" % optionsUsage(options)

	if len(sys.argv) == 1:
		sys.stderr
		sys.stderr.write(usage + "\n")
		sys.exit(1)

	try:
		opts, args = getopt.getopt(sys.argv[1:], '', ['version', 'help'])
	except getopt.GetoptError, message:
		sys.stderr.write(usage + "\n")
		sys.exit(1)
	for arg, val in opts:
		if arg == '--version':
			print getVersion()
			sys.exit(0)
		elif arg == '--help':
			print usage
			sys.exit(0)

	ignored = ""
	for javadocdir in args:
		# ensure dir is a accessible
		if not os.path.exists(javadocdir):
			sys.stderr.write("javadocpp: unable to access %s\n" % javadocdir)
		elif not os.path.isdir(javadocdir):
			sys.stderr.write("javadocpp: not a directory: %s\n" % javadocdir)
		else:
			# process dir
			os.path.walk(javadocdir, postProcess, ignored)

main()
