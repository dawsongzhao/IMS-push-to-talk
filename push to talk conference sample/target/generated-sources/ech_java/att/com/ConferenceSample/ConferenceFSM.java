//
// This file was generated by ech2java. Do not modify.
//

// ECharts source top line tag: 7
package att.com.ConferenceSample;
// ECharts source bottom line tag: 7

import org.echarts.*;
import org.echarts.monitor.*;
// ECharts source top line tag: 9
import  java.util.Properties;
// ECharts source bottom line tag: 9
// ECharts source top line tag: 10
import  javax.servlet.ServletContext;
// ECharts source bottom line tag: 10
// ECharts source top line tag: 11
import  javax.servlet.sip.*;
// ECharts source bottom line tag: 11
// ECharts source top line tag: 12
import  javax.servlet.sip.ar.*;
// ECharts source bottom line tag: 12
// ECharts source top line tag: 13
import  org.echarts.*;
// ECharts source bottom line tag: 13
// ECharts source top line tag: 14
import  org.echarts.servlet.sip.*;
// ECharts source bottom line tag: 14
// ECharts source top line tag: 15
import  org.echarts.servlet.sip.messages.*;
// ECharts source bottom line tag: 15
// ECharts source top line tag: 16
import  org.echarts.servlet.sip.machines.*;
// ECharts source bottom line tag: 16
// ECharts source top line tag: 17
import  att.com.ConferenceSample.*;
// ECharts source bottom line tag: 17
// ECharts source top line tag: 18
import  finals.*;
// ECharts source bottom line tag: 18
// ECharts source top line tag: 19
import  messages.*;
// ECharts source bottom line tag: 19
// ECharts source top line tag: 20
import  java.net.Socket;
// ECharts source bottom line tag: 20
// ECharts source top line tag: 21
import  java.io.OutputStream;
// ECharts source bottom line tag: 21
// ECharts source top line tag: 22
import  java.io.PrintWriter;
// ECharts source bottom line tag: 22
// ECharts source top line tag: 23
import  javax.servlet.sip.*;
// ECharts source bottom line tag: 23

/**
 * Represents a Single Conference Room Machine
 */
public class ConferenceFSM extends TransitionMachine {
// Static declarations for ConferenceFSM
private static final int ConferenceFSM_NUM_STATES = 2;
private static State[] ConferenceFSM_states = new State[ConferenceFSM_NUM_STATES];
private static void initialize_ConferenceFSM_states_0() {
ConferenceFSM_states[0] = new OrState("INIT", BasicMachineConstructor.BASIC_MACHINE_CONSTRUCTOR, null, null, false);
ConferenceFSM_states[1] = new OrState("READY", new MachineConstructor() { public Machine newInstance(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception { return ((ConferenceFSM) parentMachine).state_READY(parentMachine, machineIndex, machineCode); }}, null, null, false);
}
static {
    initialize_ConferenceFSM_states_0();
}
private static MachineMessageTransitions[] ConferenceFSM_messageTransitions = initializeMessageTransitions(new MachineMessageTransitions[ConferenceFSM_NUM_STATES]);
private static MachineMessagelessTransitions[] ConferenceFSM_messagelessTransitions = initializeMessagelessTransitions(new MachineMessagelessTransitions[ConferenceFSM_NUM_STATES]);
private static void initialize_ConferenceFSM_transitions_0() {
addMessagelessTransition(ConferenceFSM_messagelessTransitions, new MessagelessTransition(new TransitionSource(new MultiStateConfiguration(0, new StateConfiguration[]{Machine.BASIC_CONFIG, Machine.VARIABLE_CONFIG}, new boolean[] {false, false}, new int[] {0, -1}, null), "[INIT]"), new CompoundTransitionTarget(null, new TransitionTarget[]{new BasicTransitionTarget(new MultiStateConfiguration(1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, new MultiStateConfiguration(-1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, new MultiStateConfiguration(1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, Machine.BASIC_CONFIG}, new boolean[] {false, false}, new int[] {-1, 0}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM) machine).get_transition_1_1_tgt_machine_binding(cfgIndex); }}), Machine.VARIABLE_CONFIG}, new boolean[] {false, false, false}, new int[] {-1, 1, -1}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM) machine).get_transition_1_1_tgt_machine_binding(cfgIndex); }})}, new boolean[] {false, false}, new int[] {-1, 2}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM) machine).get_transition_1_1_tgt_machine_binding(cfgIndex); }}), "[READY.PLACE_CALL.START]", new MessagelessGuardMethod() { public boolean invoke(final Machine machine) throws Exception { return ((ConferenceFSM) machine).transition_1_1_guard(); }}, null)})), 0);
}
static {
    initialize_ConferenceFSM_transitions_0();
}
// Static declarations for ConferenceFSM.READY
private static final int READY_NUM_STATES = 3;
private static State[] READY_states = new State[READY_NUM_STATES];
private static void initialize_READY_states_0() {
READY_states[0] = new AndState("WAIT", BasicMachineConstructor.BASIC_MACHINE_CONSTRUCTOR, null, null, false);
READY_states[1] = new AndState("PLACE_CALL", new MachineConstructor() { public Machine newInstance(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception { return ((ConferenceFSM.READY) parentMachine).state_PLACE_CALL(parentMachine, machineIndex, machineCode); }}, null, null, false);
READY_states[2] = new AndState("PARALLEL", new MachineConstructor() { public Machine newInstance(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception { return ((ConferenceFSM.READY) parentMachine).state_PARALLEL(parentMachine, machineIndex, machineCode); }}, null, null, false);
}
static {
    initialize_READY_states_0();
}
private static MachineMessageTransitions[] READY_messageTransitions = initializeMessageTransitions(new MachineMessageTransitions[READY_NUM_STATES]);
private static MachineMessagelessTransitions[] READY_messagelessTransitions = initializeMessagelessTransitions(new MachineMessagelessTransitions[READY_NUM_STATES]);
private static void initialize_READY_transitions_0() {
addMessageTransition(READY_messageTransitions, new MessageTransition(new PortMethod() { public LocalPort invoke(final Machine machine) { return ((ConferenceFSM.READY) machine).transition_1_port(); }}, Invite.class, new TransitionSource(new MultiStateConfiguration(-1, new StateConfiguration[]{Machine.BASIC_CONFIG, Machine.VARIABLE_CONFIG, Machine.VARIABLE_CONFIG}, new boolean[] {false, false, false}, new int[] {0, -1, -1}, null), "[WAIT]"), new CompoundTransitionTarget(null, new TransitionTarget[]{new BasicTransitionTarget(new MultiStateConfiguration(-1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, new MultiStateConfiguration(1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, Machine.BASIC_CONFIG}, new boolean[] {false, false}, new int[] {-1, 0}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM.READY) machine).get_transition_1_1_tgt_machine_binding(cfgIndex); }}), Machine.VARIABLE_CONFIG}, new boolean[] {false, false, false}, new int[] {-1, 1, -1}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM.READY) machine).get_transition_1_1_tgt_machine_binding(cfgIndex); }}), "[PLACE_CALL.START]", null, new MessageActionMethod() { public void invoke(final Machine machine, final LocalPort port, final Object message) throws Exception { ((ConferenceFSM.READY) machine).transition_1_1_action(port, (Invite) message); }})}), true), -1);
addMessagelessTransition(READY_messagelessTransitions, new MessagelessTransition(new TransitionSource(new MultiStateConfiguration(-1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, new MultiStateConfiguration(1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, Machine.BASIC_CONFIG}, new boolean[] {false, false}, new int[] {-1, 0}, null), Machine.VARIABLE_CONFIG}, new boolean[] {false, false, false}, new int[] {-1, 1, -1}, null), "[PLACE_CALL.START]"), new CompoundTransitionTarget(null, new TransitionTarget[]{new BasicTransitionTarget(new MultiStateConfiguration(-1, new StateConfiguration[]{Machine.VARIABLE_CONFIG, new MultiStateConfiguration(0, new StateConfiguration[]{Machine.BASIC_CONFIG, Machine.VARIABLE_CONFIG}, new boolean[] {false, false}, new int[] {0, -1}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM.READY) machine).get_transition_2_1_tgt_machine_binding(cfgIndex); }}), new DynamicStateConfiguration(new StateConfiguration[]{Machine.NEW_CONFIG}, new int[]{2}, new boolean[]{false}, new boolean[]{false}, new DynamicSubmachineIndexGettor() { public final int getIndex(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM.READY) machine).get_transition_2_1_tgt_cached_index(cfgIndex); }}, new DynamicSubmachineIndexSettor() { public final void setIndex(final int cfgIndex, final Machine machine, final int index) throws Exception { ((ConferenceFSM.READY) machine).set_transition_2_1_tgt_cached_index(cfgIndex, index); }}, new DynamicSubmachineIndexGettor() { public final int getIndex(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM.READY) machine).get_transition_2_1_tgt_user_index(cfgIndex); }}, new DynamicSubmachineIndexSettor() { public final void setIndex(final int cfgIndex, final Machine machine, final int index) throws Exception { ((ConferenceFSM.READY) machine).set_transition_2_1_tgt_user_index(cfgIndex, index); }})}, new boolean[] {false, false, false}, new int[] {-1, 1, 3}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM.READY) machine).get_transition_2_1_tgt_machine_binding(cfgIndex); }}), "[PLACE_CALL.IDLE, PARALLEL.NEW]", null, new MessagelessActionMethod() { public void invoke(final Machine machine) throws Exception { ((ConferenceFSM.READY) machine).transition_2_1_action(); }})})), -1);
addMessageTransition(READY_messageTransitions, new MessageTransition(new PortMethod() { public LocalPort invoke(final Machine machine) { return ((ConferenceFSM.READY) machine).transition_3_port(); }}, OutLegMessage.class, new TransitionSource(new MultiStateConfiguration(-1, new StateConfiguration[]{Machine.BASIC_CONFIG, Machine.VARIABLE_CONFIG, Machine.VARIABLE_CONFIG}, new boolean[] {false, false, false}, new int[] {0, -1, -1}, null), "[WAIT]"), new CompoundTransitionTarget(null, new TransitionTarget[]{new BasicTransitionTarget(new MultiStateConfiguration(-1, new StateConfiguration[]{Machine.BASIC_CONFIG, Machine.VARIABLE_CONFIG, Machine.VARIABLE_CONFIG}, new boolean[] {false, false, false}, new int[] {0, -1, -1}, new SubmachineBindingGettor() { public final Machine getSubmachine(final int cfgIndex, final Machine machine) throws Exception { return ((ConferenceFSM.READY) machine).get_transition_3_1_tgt_machine_binding(cfgIndex); }}), "[WAIT]", null, new MessageActionMethod() { public void invoke(final Machine machine, final LocalPort port, final Object message) throws Exception { ((ConferenceFSM.READY) machine).transition_3_1_action(port, (OutLegMessage) message); }})}), true), -1);
}
static {
    initialize_READY_transitions_0();
}
// Static declarations for ConferenceFSM.READY.PLACE_CALL
private static final int PLACE_CALL_NUM_STATES = 2;
private static State[] PLACE_CALL_states = new State[PLACE_CALL_NUM_STATES];
private static void initialize_PLACE_CALL_states_0() {
PLACE_CALL_states[0] = new OrState("IDLE", BasicMachineConstructor.BASIC_MACHINE_CONSTRUCTOR, null, null, false);
PLACE_CALL_states[1] = new OrState("START", BasicMachineConstructor.BASIC_MACHINE_CONSTRUCTOR, null, null, false);
}
static {
    initialize_PLACE_CALL_states_0();
}
private static MachineMessageTransitions[] PLACE_CALL_messageTransitions = initializeMessageTransitions(new MachineMessageTransitions[PLACE_CALL_NUM_STATES]);
private static MachineMessagelessTransitions[] PLACE_CALL_messagelessTransitions = initializeMessagelessTransitions(new MachineMessagelessTransitions[PLACE_CALL_NUM_STATES]);
// Declarations for ConferenceFSM
// ECharts source top line tag: 119
public ConferenceFSM(FeatureBox box, Properties servletProps, ServletContext servletContext, InternalPort extPort, SipServletRequest initInvite, sipToJavaNotification sipToJavaNotify, final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
super(ConferenceFSM_states, ConferenceFSM_messageTransitions, ConferenceFSM_messagelessTransitions, ConferenceFSM.class.getName(), parentMachine, machineIndex, machineCode);
this.box            = box;
		this.servletProps   = servletProps;
		this.servletContext = servletContext;		
		this.internalPort = extPort;
		this.sipToJavaNotify = sipToJavaNotify;
		this.confIncomingEventsPort = new InternalPort(this,"outLegsIncoming"); 
		boxPort = box.getBoxPort();
		this.initialInvite = initInvite;;
}

public ConferenceFSM(FeatureBox box, Properties servletProps, ServletContext servletContext, InternalPort extPort, SipServletRequest initInvite, sipToJavaNotification sipToJavaNotify) throws Exception {
this(box, servletProps, servletContext, extPort, initInvite, sipToJavaNotify, null, -1, null);
}
// ECharts source bottom line tag: 119

// ECharts source top line tag: 29

	FeatureBox     box;
	Properties     servletProps;
	ServletContext servletContext;

	/** Incoming Port from ConferenceSampleMachine **/
	private InternalPort internalPort = null;
	/** Incoming Port from Each of the OutLegsFSM **/
	private InternalPort confIncomingEventsPort;

	sipToJavaNotification sipToJavaNotify;
		
	BoxPort boxPort;
	/** Initated only if a new invite was recieved from the user**/
	SipPort caller;
	
	private int forkLegsCounter = 0;
	
	private String talkerIP = NO_CALLER_IP;
	private static final String NO_CALLER_IP = "0.0.0.0";
	
	private SipServletRequest initialInvite = null;
		
	private boolean sendCmdToMediaServer(OutLegMessage msg) {
		System.out.println("About to send to Media Replicator "+msg);
		PrintWriter printWriter = null;
		boolean success = false;
		try {
			  Socket socket = new Socket(MediaServerFinals.MEDIA_REPLICATOR_IP, MediaServerFinals.MEDIA_REPLICATOR_CONF_PORT);			  
		      OutputStream outputStream = socket.getOutputStream();
		      printWriter = new PrintWriter((outputStream));
		      printWriter.println(msg.generateCmd());
		      success = true;
		} catch(Exception e) {
		      System.out.println("Error Writing to " + MediaServerFinals.MEDIA_REPLICATOR_IP + e);
		} finally {
			if (printWriter != null) {
				 printWriter.flush();
				 printWriter.close(); 
			}
			return success;
		 }		
	}
	
	/**
	 * Handles Messages for the Media Replicator sent by the OutLegFSM
	 */
	private void handleConfIncomingMessage(OutLegMessage message) {
	
		switch(message.getMsCommnad()) {
			case PTTON: 
			if (talkerIP.equals(NO_CALLER_IP))
			{
				sipToJavaNotify.pttON(message.getUsername());
				sendCmdToMediaServer(message);
				talkerIP = message.getIp();
			}
			break;
			case PTTOFF:
			if (talkerIP.equals(message.getIp()))
			{
			    sipToJavaNotify.pttOFF(message.getUsername());
			    sendCmdToMediaServer(message);
			    talkerIP = NO_CALLER_IP;
			}
			break;
			case ADD:
			    sipToJavaNotify.addUser(message.getUsername());
			    sendCmdToMediaServer(message);
				break;
				case REMOVE:
				 if (talkerIP.equals(message.getIp()))
			{
			    sipToJavaNotify.pttOFF(message.getUsername());
			    sendCmdToMediaServer(message.cloneMsg(MediaServerCommand.PTTOFF));
			    talkerIP = NO_CALLER_IP;
			}
			sipToJavaNotify.removeUser(message.getUsername());
			sendCmdToMediaServer(message);
				break;
			case ILLEGAL:
				System.out.println("ERROR " + message);	    			    	
				break;	    		
			default:
				System.out.println("Sending to media Server " + message);    				
				sendCmdToMediaServer(message);
		}
	}
;
// ECharts source bottom line tag: 29
// ECharts source top line tag: 133
 READY READY = null;
public Machine state_READY(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
READY = new READY(parentMachine, machineIndex, machineCode);
return READY;
}
// ECharts source bottom line tag: 133
final protected void clearSubmachineReference(final int index) {
switch(index) {
case 1: READY = null; break;
default: break;
}
}
// ECharts source top line tag: 164

final private Machine get_transition_1_1_tgt_machine_binding(final int cfgIndex) throws Exception {
	switch (cfgIndex) {

    default:
        throw new MachineException("No subconfiguration machine binding defined for subconfiguration index " + cfgIndex);
	}
}
public boolean transition_1_1_guard() throws Exception {
return (internalPort) != (null);
}
// ECharts source bottom line tag: 164
// Declarations for ConferenceFSM.READY
public class READY extends TransitionMachine {
public READY(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
super(READY_states, READY_messageTransitions, READY_messagelessTransitions, ConferenceFSM.READY.class.getName(), parentMachine, machineIndex, machineCode);
}
// ECharts source top line tag: 136
 PLACE_CALL PLACE_CALL = null;
public Machine state_PLACE_CALL(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
PLACE_CALL = new PLACE_CALL(parentMachine, machineIndex, machineCode);
return PLACE_CALL;
}
// ECharts source bottom line tag: 136
// ECharts source top line tag: 141
 DynamicMachine<OutLegFSM> PARALLEL = null;
public OutLegFSM state_PARALLEL_element(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
return new OutLegFSM(box, caller, initialInvite, confIncomingEventsPort, parentMachine, machineIndex, machineCode);
}
private final MachineConstructor state_PARALLEL_element_constructor = new MachineConstructor() {
public Machine newInstance(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
return ((ConferenceFSM.READY) parentMachine.getParentMachine()).state_PARALLEL_element(parentMachine, machineIndex, machineCode);
}
};
public Machine state_PARALLEL(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
PARALLEL = new DynamicMachine<OutLegFSM>(state_PARALLEL_element_constructor, 16, "MachineArray<OutLegFSM>", parentMachine, machineIndex, machineCode);
return PARALLEL;
}
// ECharts source bottom line tag: 141
final protected void clearSubmachineReference(final int index) {
switch(index) {
case 1: PLACE_CALL = null; break;
case 2: PARALLEL = null; break;
default: break;
}
}
// ECharts source top line tag: 143
public LocalPort transition_1_port() {
return internalPort;
}

final private Machine get_transition_1_1_tgt_machine_binding(final int cfgIndex) throws Exception {
	switch (cfgIndex) {

    default:
        throw new MachineException("No subconfiguration machine binding defined for subconfiguration index " + cfgIndex);
	}
}
public void transition_1_1_action(final LocalPort port, final Invite message) throws Exception {
initialInvite = message;;
;
}
// ECharts source bottom line tag: 143
// ECharts source top line tag: 149

final private int[] transition_2_1_tgt_cached_indices = new int[1];

final private int get_transition_2_1_tgt_cached_index(final int cfgIndex) throws Exception {
    switch (cfgIndex) {

    case 2:
	    return transition_2_1_tgt_cached_indices[0];

    default:
        throw new MachineException("No dynamic subconfiguration gettor defined for subconfiguration index " + cfgIndex);
	}
}
final private void set_transition_2_1_tgt_cached_index(final int cfgIndex, final int submachineIndex) throws Exception {
    switch (cfgIndex) {

    case 2:
	    transition_2_1_tgt_cached_indices[0] = submachineIndex;
		break;

    default:
        throw new MachineException("No dynamic subconfiguration settor defined for subconfiguration index " + cfgIndex);
	}
}
final private int get_transition_2_1_tgt_user_index(final int cfgIndex) throws Exception {
	switch (cfgIndex) {

    default:
        throw new MachineException("No dynamic subconfiguration gettor defined for subconfiguration index " + cfgIndex);
	}
}

final private void set_transition_2_1_tgt_user_index(final int cfgIndex, final int submachineIndex) throws Exception {
	switch (cfgIndex) {

    default:
	    throw new MachineException("No dynamic subconfiguration settor defined for subconfiguration index " + cfgIndex);
    }
}

final private Machine get_transition_2_1_tgt_machine_binding(final int cfgIndex) throws Exception {
	switch (cfgIndex) {

    default:
        throw new MachineException("No subconfiguration machine binding defined for subconfiguration index " + cfgIndex);
	}
}
public void transition_2_1_action() throws Exception {
putEvent(new DebugEvent("New Caller"));
			caller = box.createSipPort("caller" + (++forkLegsCounter));;
}
// ECharts source bottom line tag: 149
// ECharts source top line tag: 156
public LocalPort transition_3_port() {
return confIncomingEventsPort;
}

final private Machine get_transition_3_1_tgt_machine_binding(final int cfgIndex) throws Exception {
	switch (cfgIndex) {

    default:
        throw new MachineException("No subconfiguration machine binding defined for subconfiguration index " + cfgIndex);
	}
}
public void transition_3_1_action(final LocalPort port, final OutLegMessage message) throws Exception {
putEvent(new DebugEvent("Got Out Leg Message " + message));
    		handleConfIncomingMessage(message);;
;
}
// ECharts source bottom line tag: 156
// Declarations for ConferenceFSM.READY.PLACE_CALL
public class PLACE_CALL extends TransitionMachine {
public PLACE_CALL(final Machine parentMachine, final int machineIndex, final MachineCode machineCode) throws Exception {
super(PLACE_CALL_states, PLACE_CALL_messageTransitions, PLACE_CALL_messagelessTransitions, ConferenceFSM.READY.PLACE_CALL.class.getName(), parentMachine, machineIndex, machineCode);
}
final protected void clearSubmachineReference(final int index) {
switch(index) {
default: break;
}
}
}
}
}
